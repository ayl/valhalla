syntax = "proto3";
option optimize_for = LITE_RUNTIME;
package valhalla;

message LatLng {
  double lat = 1;
  double lng = 2;
}

message BoundingBox {
  LatLng min_ll = 1;
  LatLng max_ll = 2;
}

message Location {
  enum Type {
    kBreak = 0;
    kThrough = 1;
    kVia = 2;
    kBreakThrough = 3;
  }

  enum SideOfStreet {
    kNone = 0;
    kLeft = 1;
    kRight = 2;
  }

  enum PreferredSide {
    either = 0;
    same = 1;
    opposite = 2;
  }

  message PathEdge {
    uint64 graph_id = 1;
    double percent_along = 2;
    LatLng ll = 3;
    SideOfStreet side_of_street = 4;
    double distance = 5;
    int32 minimum_reachability = 6; //deprecated
    bool begin_node = 7;
    bool end_node = 8;
    repeated string names = 10;
    int32 outbound_reach = 11;
    int32 inbound_reach = 12;
    float heading = 13;
  }

  message SearchFilter {
    // frc
    RoadClass min_road_class = 1; // lowest road class to allow in loki results
    RoadClass max_road_class = 2; // highest road class to allow in loki results
    // form of way
    bool exclude_tunnel  = 3;   // whether to exclude tunnels from loki results (default false)
    bool exclude_bridge  = 4;   // whether to exclude bridges from loki results (default false)
    bool exclude_ramp  = 5;     // whether to exclude roads with ramp use from loki results (default false)
    
    bool exclude_closures  = 6; // whether to exclude roads marked as closed due to traffic (default true)
  }

  //inputs
  LatLng ll = 1;
  Type type = 2;
  oneof optional_heading {
    uint32 heading = 3;                                 // 0-359
  }
  string name = 4;
  string street = 5;
  string city = 6;
  string state = 7;
  string postal_code = 8;
  string country = 9;
  string phone = 10;
  string url = 11;
  string date_time = 12;
  SideOfStreet side_of_street = 13;
  oneof optional_heading_tolerance {
    uint32 heading_tolerance = 14;
  }
  oneof optional_node_snap_tolerance {
   uint32 node_snap_tolerance = 15;
  }
  oneof optional_way_id {
    uint64 way_id = 16;
  }
  oneof optional_minimum_reachability {
    uint32 minimum_reachability = 17;
  }
  uint32 radius = 18;
  oneof optional_accuracy {
    uint32 accuracy = 19;
  }
  oneof optional_time {
    double time = 20;
  }
  oneof optional_rank_candidates {
    bool rank_candidates = 21;
  }
  PreferredSide preferred_side = 22;
  LatLng display_ll = 23;
  oneof optional_search_cutoff {
    uint32 search_cutoff = 24;
  }
  oneof optional_street_side_tolerance {
    uint32 street_side_tolerance = 25;
  }
  SearchFilter search_filter = 26;
  oneof optional_street_side_max_distance {
    uint32 street_side_max_distance = 27;
  }
  oneof optional_preferred_layer {
    int32 preferred_layer = 28;
  }

  //outputs
  repeated PathEdge path_edges = 50;
  repeated PathEdge filtered_edges = 51;
  uint32 original_index = 52;
  LatLng projected_ll = 53;
  uint32 leg_shape_index = 54;
  double distance_from_leg_origin = 55;
  uint32 route_index = 56;
  uint32 waypoint_index = 57;
}

message TransitEgressInfo {
  string onestop_id = 1;        // Unique transitland ID
  string name = 2;              // The name of the egress
  LatLng ll = 3;                // Latitude, longitude of the egress
}

message TransitStationInfo {
  string onestop_id = 1;        // Unique transitland ID
  string name = 2;              // The name of the station
  LatLng ll = 3;                // Latitude, longitude of the station
}

message BikeShareStationInfo {
  string name = 1;
  string ref = 2;
  uint32 capacity = 3;
  string network = 4;
  string operator = 5;
  float rent_cost = 6;
  float return_cost = 7;
}

message TransitPlatformInfo {
  enum Type {
    kStop = 0;
    kStation = 1;
  }

  Type type = 1;                  // The type of stop (station or simple stop)
  string onestop_id = 2;          // Unique transitland ID
  string name = 3;                // The name of the platform
  string arrival_date_time = 4;   // ISO 8601 arrival date/time YYYY-MM-DDThh:mm
  string departure_date_time = 5; // ISO 8601 departure date/time YYYY-MM-DDThh:mm
  bool assumed_schedule = 6;      // true if the times are based on an assumed schedule
  LatLng ll = 7;                  // Latitude, longitude of the transit stop
  string station_onestop_id = 8;  // Unique transitland station ID
  string station_name = 9;        // The station name of the platform
}

message TransitRouteInfo {
  string onestop_id = 1;
  uint32 block_id = 2;
  uint32 trip_id = 3;
  string short_name = 4;
  string long_name = 5;
  string headsign = 6;
  uint32 color = 7;
  uint32 text_color = 8;
  string description = 9;
  string operator_onestop_id = 10;
  string operator_name = 11;
  string operator_url = 12;
  repeated TransitPlatformInfo transit_stops = 13;
}

message Pronunciation {
  enum Alphabet {
    kIpa = 0;
    kXKatakana = 1;
    kXJeita = 2;
    kNtSampa = 3;
  }
  Alphabet alphabet = 1;
  string value = 2;
}

message StreetName {
  string value = 1;                // The actual street name value, examples: I 95 North or Derry Street
  bool is_route_number = 2;        // true if the street name is a reference route number such as: I 81 South or US 322 West
  Pronunciation pronunciation = 3; // The pronunciation associated with this street name
}

message TurnLane {
  enum State {
    kInvalid = 0;
    kValid = 1;
    kActive = 2;
  }
  uint32 directions_mask = 1;
  State state = 2;
  uint32 active_direction = 3;
}

enum RoadClass {
  kMotorway = 0;
  kTrunk = 1;
  kPrimary = 2;
  kSecondary = 3;
  kTertiary = 4;
  kUnclassified = 5;
  kResidential = 6;
  kServiceOther = 7;
}

message TaggedValue {
  enum Type {
    kNone = 0;
    kLayer = 1;
    kBssInfo = 3;
    // we used to have bug when we encoded 1 and 2 as their ASCII codes, but not actual 1 and 2 values
    // see https://github.com/valhalla/valhalla/issues/3262
    kTunnel = 49; // static_cast<uint8_t>('1')
    kBridge = 50; // static_cast<uint8_t>('2')
  }
  string value = 1;   // The actual tagged name value, examples: Ted Williams Tunnel
  Type type = 2;      // The type of tagged name (tunnel or bridge)
}

enum TravelMode {
  kDrive = 0;
  kPedestrian = 1;
  kBicycle = 2;
  kTransit = 3;
}

// TODO: review and update as needed
enum VehicleType {
  kCar = 0;
  kMotorcycle = 1;
  kAutoBus = 2;
  kTractorTrailer = 3;
  kMotorScooter = 4;
}

enum PedestrianType {
  kFoot = 0;
  kWheelchair = 1;
  kSegway = 2;
}

enum BicycleType {
  kRoad = 0;
  kCross = 1;
  kHybrid = 2;
  kMountain = 3;
}

enum TransitType {
  kTram = 0;
  kMetro = 1;
  kRail = 2;
  kBus = 3;
  kFerry = 4;
  kCableCar = 5;
  kGondola = 6;
  kFunicular = 7;
}
